{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nfunction AlgoritmosComponent_tr_27_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\")(1, \"td\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"td\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"td\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const algoritmo_r1 = ctx.$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(algoritmo_r1.N);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(algoritmo_r1.log_N);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(algoritmo_r1._log_N_);\n  }\n}\nexport class AlgoritmosComponent {\n  functionTransf2() {\n    setInterval(() => {\n      this.N2 = Math.floor(Math.random() * 100000000) + 1;\n    }, 30000);\n    return this.N2;\n  }\n  functionTransf() {\n    setInterval(() => {\n      this.N = Math.floor(Math.random() * 100000000) + 1;\n    }, 30000);\n    return this.N;\n  }\n  constructor() {\n    /*\r\n            Piso do logaritmo na base 2\r\n    O logaritmo na base 2 de um número N é o expoente a que 2 deve ser elevado para\r\n    produzir N.  O logaritmo na base 2 de N é denotado por log N.  É claro que log N\r\n    só está definido se N é estritamente positivo.\r\n            Problema: dado um inteiro estritamente positivo N, calcular o piso de log N.\r\n            O piso de log N, usualmente denotado por  ⌊log N⌋, é aproximadamente igual ao número\r\n    de bits na representação binária de N.  A seguinte tabela mostra alguns valores de\r\n    log N (aproximados até a terceira casa decimal) bem como os correspondentes valores\r\n    de ⌊log N⌋:\r\n            */\n    this.algoritmos = [{\n      N: 10,\n      log_N: '3.322',\n      _log_N_: '3'\n    }, {\n      N: 100,\n      log_N: '6.644',\n      _log_N_: '7'\n    }, {\n      N: 1000,\n      log_N: '9.966',\n      _log_N_: '10'\n    }, {\n      N: 10000,\n      log_N: '13.288',\n      _log_N_: '13'\n    }, {\n      N: 100000,\n      log_N: '16.611',\n      _log_N_: '17'\n    }, {\n      N: 1000000,\n      log_N: '19.933',\n      _log_N_: '20'\n    }, {\n      N: 10000000,\n      log_N: '23.255',\n      _log_N_: '23'\n    }, {\n      N: 100000000,\n      log_N: '26.578',\n      _log_N_: '27'\n    }];\n    /*criando um intervalo de número inteiro com setInterval()*/\n    this.N = Math.floor(Math.random() * 100000000) + 1;\n    this.N2 = Math.floor(Math.random() * 100000000) + 1;\n  }\n  NgModule() {}\n  funcaoLog10ComFloor(N) {\n    let x;\n    x = log10(N) / log(2);\n    return Math.floor(Math.log10(N));\n  }\n  funcaoLogN_Divisao(N) {\n    let i = 0;\n    let n = N;\n    while (n > 1) {\n      n = 2 / n;\n      i += 1;\n    }\n    return i;\n  }\n  funcaoLogN_Multiplicacao(N) {\n    let i = 0;\n    let n = 1;\n    while (n <= N / 2) {\n      n = 2 * n;\n      i += 1;\n    }\n    return i;\n  }\n}\nAlgoritmosComponent.ɵfac = function AlgoritmosComponent_Factory(t) {\n  return new (t || AlgoritmosComponent)();\n};\nAlgoritmosComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: AlgoritmosComponent,\n  selectors: [[\"app-algoritmos\"]],\n  decls: 28,\n  vars: 9,\n  consts: [[1, \"box-body\", \"box-title\", \"text-center\"], [1, \"box\"], [1, \"box-header\", \"box-title\", \"text-center\"], [1, \"\"], [\"id\", \"example1\", 1, \"table\", \"table-bordered\", \"table-striped\"], [4, \"ngFor\", \"ngForOf\"]],\n  template: function AlgoritmosComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0)(1, \"h1\");\n      i0.ɵɵtext(2, \"Algoritmos Estudos\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(3, \"p\");\n      i0.ɵɵtext(4);\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(5, \"p\");\n      i0.ɵɵtext(6);\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(7, \"p\");\n      i0.ɵɵtext(8);\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(9, \"p\");\n      i0.ɵɵtext(10);\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelement(11, \"hr\");\n      i0.ɵɵelementStart(12, \"div\", 1)(13, \"div\", 2)(14, \"h3\", 3);\n      i0.ɵɵtext(15, \"Algoritmos Estudos\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(16, \"div\", 0)(17, \"table\", 4)(18, \"thead\")(19, \"tr\")(20, \"th\");\n      i0.ɵɵtext(21, \"N\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(22, \"th\");\n      i0.ɵɵtext(23, \"log N\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(24, \"th\");\n      i0.ɵɵtext(25, \"\\u230Alog N\\u230B\");\n      i0.ɵɵelementEnd()()();\n      i0.ɵɵelementStart(26, \"tbody\");\n      i0.ɵɵtemplate(27, AlgoritmosComponent_tr_27_Template, 7, 3, \"tr\", 5);\n      i0.ɵɵelementEnd()()()();\n    }\n    if (rf & 2) {\n      i0.ɵɵadvance(4);\n      i0.ɵɵtextInterpolate2(\"\", \"functionTransf() > \", \"\", ctx.functionTransf(), \"\");\n      i0.ɵɵadvance(2);\n      i0.ɵɵtextInterpolate2(\"\", \"functionTransf2() > \", \"\", ctx.functionTransf2(), \"\");\n      i0.ɵɵadvance(2);\n      i0.ɵɵtextInterpolate2(\"\", \"funcaoLogN_Multiplicacao() > \", \"\", ctx.funcaoLogN_Multiplicacao(ctx.functionTransf()), \"\");\n      i0.ɵɵadvance(2);\n      i0.ɵɵtextInterpolate2(\"\", \"funcaoLogN_Divisao() > \", \"\", ctx.funcaoLogN_Divisao(ctx.functionTransf2()), \"\");\n      i0.ɵɵadvance(17);\n      i0.ɵɵproperty(\"ngForOf\", ctx.algoritmos);\n    }\n  },\n  dependencies: [i1.NgForOf],\n  styles: [\"@charset \\\"UTF-8\\\";\\n\\n[_nghost-%COMP%] {\\n  \\n  \\n  \\n  margin: 0 auto;\\n  \\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  max-width: 60%;\\n  display: block;\\n  padding: 2rem;\\n  \\n}\\n[_nghost-%COMP%]   h3[_ngcontent-%COMP%] {\\n  font-size: 2rem;\\n  font-weight: 700;\\n  margin-bottom: 1rem;\\n}\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9hcHAvYWxnb3JpdG1vcy9hbGdvcml0bW9zL2FsZ29yaXRtb3MuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCO0FBQWhCLGtEQUFBO0FBQ0E7RUFDSSxzRkFBQTtFQUVBLG9FQUFBO0VBQ0EsZ0NBQUE7RUFDQSxjQUFBO0VBQ0EsOEJBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxtQkFBQTtFQUNBLGNBQUE7RUFDQSxjQUFBO0VBQ0EsYUFBQTtFQUVBLHlCQUFBO0FBQUo7QUFDSTtFQUNJLGVBQUE7RUFDQSxnQkFBQTtFQUNBLG1CQUFBO0FBQ1IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc3Bhw4PCp2FuZG8gYSBjYWl4YSBlbSB0b2RvcyBvcyBsYWRvcyBkYSBww4PCoWdpbmEgKi9cbjpob3N0IHtcbiAgICAvKkNyaWFuZG8gZnVuZG8gZW0gZGVncmFkw4PCqiBkZSAzIGNvcmVzIHBhcmEgYSB0ZWxhIGludGVpcmEgcHJlZW5jaGVuZG8gdG9kYXMgYXMgcGFydGVzKi9cbiAgICAvLyBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMwMGJmZmYsICMwMGZmZmYsICMwMDUxZmYpO1xuICAgIC8qYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjMDBiZmZmLCAjMDBmZmZmLCAjMDA1MWZmKTsqL1xuICAgIC8qIENlbnRyYWxpemFuZG8gbmEgaG9yaXpvbnRhbCAqL1xuICAgIG1hcmdpbjogMCBhdXRvO1xuICAgIC8qIENlbnRyYWxpemFuZG8gbmEgdmVydGljYWwgKi9cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBtYXgtd2lkdGg6IDYwJTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwYWRkaW5nOiAycmVtO1xuXG4gICAgLyogRXN0aWxpemFuZG8gbyB0w4PCrXR1bG8gKi9cbiAgICBoMyB7XG4gICAgICAgIGZvbnQtc2l6ZTogMnJlbTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcbiAgICB9XG5cbn0iXSwic291cmNlUm9vdCI6IiJ9 */\"]\n});","map":{"version":3,"mappings":"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","names":["i0","AlgoritmosComponent","functionTransf2","setInterval","N2","Math","floor","random","functionTransf","N","constructor","log_N","_log_N_","NgModule","funcaoLog10ComFloor","x","log10","log","funcaoLogN_Divisao","i","n","funcaoLogN_Multiplicacao","selectors","decls","vars","consts","template"],"sourceRoot":"","sources":["E:\\ProjetosProgramacao_2023\\ProjetoProgramacao_EstudosANGULAR\\ProjetoProgramacao_EstudosANGULAR\\algoritmos\\src\\app\\algoritmos\\algoritmos\\algoritmos.component.html","E:\\ProjetosProgramacao_2023\\ProjetoProgramacao_EstudosANGULAR\\ProjetoProgramacao_EstudosANGULAR\\algoritmos\\src\\app\\algoritmos\\algoritmos\\algoritmos.component.ts"],"sourcesContent":["<!--Usando a função funcaoLogN_Multiplicacao(N) com interpolation-->\n<div class=\"box-body box-title text-center\">\n  <h1>Algoritmos Estudos</h1>\n  <p>{{ \"functionTransf() > \" }}{{ functionTransf() }}</p>\n  <p>{{ \"functionTransf2() > \" }}{{ functionTransf2() }}</p>\n  <p>{{ \"funcaoLogN_Multiplicacao() > \" }}{{ funcaoLogN_Multiplicacao(functionTransf()) }}</p>\n  <p>{{ \"funcaoLogN_Divisao() > \" }}{{ funcaoLogN_Divisao(functionTransf2()) }}</p>\n</div>\n\n<hr />\n\n<div class=\"box\">\n  <div class=\"box-header box-title text-center\">\n    <!--Centralizar o título no centro da página na hozontal usando bootstrap-->\n    <h3 class=\"\">Algoritmos Estudos</h3>\n  </div>\n  <div class=\"box-body box-title text-center\">\n    <table id=\"example1\" class=\"table table-bordered table-striped\">\n      <thead>\n        <tr>\n          <th>N</th>\n          <th>log N</th>\n          <th>⌊log N⌋</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr *ngFor=\"let algoritmo of algoritmos\">\n          <td>{{ algoritmo.N }}</td>\n          <td>{{ algoritmo.log_N }}</td>\n          <td>{{ algoritmo._log_N_ }}</td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</div>\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-algoritmos',\n  templateUrl: './algoritmos.component.html',\n  styleUrls: ['./algoritmos.component.scss']\n})\nexport class AlgoritmosComponent {\n\n  /*\n\n  Piso do logaritmo na base 2\n  O logaritmo na base 2 de um número N é o expoente a que 2 deve ser elevado para \n  produzir N.  O logaritmo na base 2 de N é denotado por log N.  É claro que log N \n  só está definido se N é estritamente positivo.\n\n  Problema: dado um inteiro estritamente positivo N, calcular o piso de log N.\n\n  O piso de log N, usualmente denotado por  ⌊log N⌋, é aproximadamente igual ao número \n  de bits na representação binária de N.  A seguinte tabela mostra alguns valores de \n  log N (aproximados até a terceira casa decimal) bem como os correspondentes valores \n  de ⌊log N⌋:\n\n  */\n\n  algoritmos = [ \n    { N: 10, log_N: '3.322', _log_N_: '3' },\n    { N: 100, log_N: '6.644', _log_N_: '7' },\n    { N: 1000, log_N: '9.966', _log_N_: '10' },\n    { N: 10000, log_N: '13.288', _log_N_: '13' },\n    { N: 100000, log_N: '16.611', _log_N_: '17' },\n    { N: 1000000, log_N: '19.933', _log_N_: '20' },\n    { N: 10000000, log_N: '23.255', _log_N_: '23' },\n    { N: 100000000, log_N: '26.578', _log_N_: '27' },\n  ];\n  /*criando um intervalo de número inteiro com setInterval()*/  \n  public N = Math.floor(Math.random() * 100000000) + 1;\n  public N2 = Math.floor(Math.random() * 100000000) + 1;\n \n  public functionTransf2(){\n    setInterval(() => {\n      this.N2 = Math.floor(Math.random() * 100000000) + 1;\n    }, 30000);\n    return this.N2;\n  }\n\n  public functionTransf(){\n    setInterval(() => {\n      this.N = Math.floor(Math.random() * 100000000) + 1;\n    }, 30000);\n    return this.N;\n  }\n\n  constructor() { }\n  NgModule() {}\n\n  funcaoLog10ComFloor( N: number ){\n    let x;\n    x = log10(N) / log(2);\n\n    return Math.floor(Math.log10(N));\n  }\n\n funcaoLogN_Divisao( N: number ){\t\n\tlet i = 0;\n\tlet n = N;\n\twhile (n > 1) {\n\t\tn = 2 / n;\n\t\ti += 1;\n\t}\n\treturn i;\n }\n \n funcaoLogN_Multiplicacao( N: number ){\n\tlet i = 0;\n\tlet n = 1;\n\twhile (n <= N/2) {\n\t\tn = 2 * n;\n\t\ti += 1;\n\t}\n\treturn i;\n }\n\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}